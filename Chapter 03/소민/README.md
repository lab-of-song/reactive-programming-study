# 3. Blocking I/O 와 Non-Blocking I/O

I/O 작업 종류: DB I/O, 파일 I/O, 네트워크 I/O

- tomcat 같은 동기식 스레드는 사용자 요청 인입 후, 다른 api 를 호출해야하는 경우 그 api 응답이 올 때 까지 대기하므로 스레드 블로킹이 발생한다.

⇒ 하나의 스레드가 I/O에 의해 블락킹 되는걸 blocking I/O 라고 한다.

## 멀티스레딩으로 플 수 없는 이유

1. 멀티스레딩으로 추가 스레드를 할당하면, 프로세스의 컨텍스트 스위칭으로 인한 스레드 전환 비용이 발생한다.

→ 두 개의 프로세스를 번갈아가면서 동시 수행되는 것 처럼 보이게 하므로 이 과정에서 프로세스를 다시 pcb에 넣었다가 빼내고 하는 과정이 컨텍스트 스위칭

→ pcb에 프로세스를 넣고 꺼내는  과정에 어ㅉ쩔 수 없이 잠깐의 cpu idle time 이 발생해서, 컨텍스트 스위칭이 많아질 수록 cpu 대기시간 총량이 길어진다.

1. 과다한 메모리 사용으로 오버헤드가 발생할 수 있다. (요청 하나당 기본적으로 스레드 1개인 구조에서, 추가 멀티스레드까지 들어가면 메모리 사용량이 늘어날 수 있다.)
2. 스레드풀에서 응답 지연이 생길 수 있다.(멀티스레딩으로 쓰이는 스레드가 너무 많으므로) (멀티스레딩으로 인한 유휴 스레드 감소 → 이건 근데 Async 처리하고 스레드풀 따로 운영하면.. 이걸로 풀 수 있지 않나?? 그래도 여전히 스레드를 잡아먹는거니까 문제가 되나)

## non-blocking I/O

작업 스레드의 종료 여부와 관계없이 요청한 스레드는 차단되지 않는다.

→ 스레드가 i/o 수행해두고 자기는 할 일 이 없으면 다시 스레드풀로 반환되기 때문에 한 스레드로 여러 요청을 처리할 수 있다. (다른 I/O 처리하도록 보내놓고 그 사이에 얘는 다른 작업 처리)

그래서 blocking I/O 보다 더 적은 수의 스레드를 쓸 수 있어서 blocking I/O 에서의 멀티스레딩 시의 문제가 생기지 않는다.\

단점: cpu를 많이 잡아먹는 작업을 하면 성능에 영향을 준다.

spring mvc: blocking I/O → 서블릿 컨테이너 기반으로, 한 요청을 하나의 스레드 할당

spring webflux: non-blocking I/O → netty 같은 비동기 non blocking I/O로, 적은 수로 더 많은 요청 처리  

- webclient: non-blocking I/O 방식으로 리액티브 타입을 전송하고 수신하는 역할

```text
Mono: 리액터의 publisher 타입 중 하나로, 단 하나의 데이터만 emit 한다.

보통 http json 응답 자체는 하나의 데이터이므로 webClient 에서 bodyToMono 를 통해 처리하기 좋다.

→ mono 가 publisher 이므로, webClient호출결과.subscribe( it → {수행할 동작, 즉 subscriber}) 으로 webclient 호출 결과를 구독한다.

**publisher 가 전달해준 데이터를 처리하기 위해서는 반드시 subscribe() 를 호출해야한다.**
```

### webflux 가 적합한 시스템

1. blocking i/o 로 처리하는데 한계가 있을만큼 대용량 트래픽을 받는 서버
2. 마이크로 서비스 기반 (다른 서비스간 호출이 자주 발생)
3. 스트리밍 시스템 또는 실시간 시스템 (스트림을 계속 전달해야하는 경우)
