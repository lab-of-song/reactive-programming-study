# Chapter 03. Blocking I/O 와 Non-Blocking I/O
## 3.1. Blocking I/O

- 스레드의 컨텍스트 스위칭
  - 스레드는 특정 프로세스에 종속된 하위 개념
  - 따라서 스레드간 컨텍스트 스위칭의 경우, 프로세스 정보를 공유하기에 교환할 필요 없이 비교적 적은 정보로 구성된 스레드 정보만 TCB (Thread Control Block) 에 저장 + reload 과정 반복
  - 프로세스 간 컨텍스트 스위칭보다 상대적으로 오버헤드 적음
- 스레드가 차단되는 문제를 보완하기 위해 `멀티스레딩` 기법 사용 가능
  - 컨텍스트 스위칭 전환 비용
  - 메모리 사용 오버헤드
    - 새로운 스레드 실행 시 JVM 은 해당 스레드를 위한 스택 영역 일부를 할당
  - 스레드 풀 응답 지연
    - 대량 요청이 발생해서 스레드풀에 사용 가능한 유휴 스레드가 없을 경우, 사용 가능 스레드가 확보되기 전까지 응답 지연 발생

## 3.2. Non-Blocking I/O
- 작업 스레드 종료 여부와 관계 없이, 요청한 스레드는 차단되지 않음
- **스레드가 차단되지 않기에 하나의 스레드로 많은 요청 처리 가능**
- Blocking I/O 방식보다 더 적은 수의 스레드 사용하기에, Blocking I/O 멀티스레딩 기법 사용할 때 발생한 문제 생기지 않음
- **사용자 요청 ~ 응답 전체 과정에서 Blocking I/O 요소 포함된 경우 Non-Blocking 이점 발휘하기 힘듦**
  - 완전한 Non-blocking I/O 여야 함

## 3.3. Spring Framework 에서의 Blocking I/O 와 Non-Blocking I/O
- Spring MVC : Blocking I/O
  - 서블릿 컨테이너 기반으로, 요청당 하나의 스레드 사용
- Spring Webflux : Non-Blocking I/O
  - **Netty 와 같은 비동기 Non-Blocking I/O 기반 서버 엔진 사용함으로써 적은 수의 스레드로 많은 수 요청 처리 가능**

## 3.4. Non-Blocking I/O 방식의 통신이 적합한 시스템
### 3.4.1. 대량의 요청 트래픽이 발생하는 시스템
- 상대적으로 적은 컴퓨팅 파워 사용함으로써 저비용 -> 고수준 성능 이끌어 낼 수 있음

### 3.4.2. 마이크로 서비스 기반 시스템
- 시스템 특성상 서비스 간 많은 수의 I/O 가 지속적으로 발생하기에 필요함

### 3.4.3. 스트리밍 또는 실시간 시스템
- 끊임없이 들어오는 무한 데이터 스트림을 전달받아서 효율적으로 처리 가능

